Index: out/src/高并发/2-2-2synchronized补充自旋锁消除锁粗化.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- out/src/高并发/2-2-2synchronized补充自旋锁消除锁粗化.md	(date 1603720911387)
+++ out/src/高并发/2-2-2synchronized补充自旋锁消除锁粗化.md	(date 1603720911387)
@@ -0,0 +1,123 @@
+
+
+
+# 自旋锁
+
+引入自旋锁背景：jdk1.6之前的synchronzied都是重量级锁，通过对象的Monitor进行加锁解锁，这是一把重量级锁
+锁的申请需要操作系统的互斥信号量支持，因此会导致从用户态，内核态，用户态的切换，操作系统对线程状态的切换
+开销很大。因此jdk开发团队引入了自旋锁提高获取锁释放锁性能。
+
+例子：重量级锁情况-》去银行柜台办理业务，a用户取完号码后被叫到柜台，此时b用户也来办理业务取号，jdk1.6之前的做法是，让用户自己
+走到休息区（操作系统帮助阻塞），自己做自己的事情，等待被叫号到柜台（操作系统帮助唤醒）。如果每个人去柜台只是去取款，耗时非常短，
+但是重量级锁仍然要求操作系统帮助阻塞和唤醒（线程状态切换），很明显线程阻塞唤醒性能消耗远大于取款消耗，很明显不合理。
+
+引入自旋锁之后-》 银行引入了取款机，用户只需要排队去取款机上取款就可以，不需要进入到休息区（线程阻塞），当a用户在取款时候，后面的b用户只需要不断地
+观察（自旋）a是否取款完成，如果发现a取款完成，后面直接上去取款。b用户线程始终出于用户态，随然自旋观察a用户，但是这个耗时相比于线程状态切换，耗时非常短。
+但是如果a后面有很多的排队用户，每个用户都在不停的自旋观察a是否取款结束，那么cpu自旋所占用的时间就变得很大。
+
+## 自旋和阻塞区别
+最大区别就是是否有线程状态的切换。自旋状态下，线程仍然是用户态，不断消耗cpu运行时间。但是阻塞状态下（休息区），线程从用户态到内核态
+转换，并且出于阻塞态的阻塞队列中，此时不会消耗cpu运行时间。
+
+# 锁消除
+
+## 锁消除背景
+锁的产生背景是多线程并发访问修改共享变量此时需要用锁来同步。但是问题来了，如果一个没有经验的程序员在不需要加锁同步的地方加了锁反而降低了效率。
+如果你有并发编程经验的话，下面的函数中的锁obj是函数内局部变量，不可能被发布到函数外部，不会被共享。 因此不存在同步问题。
+
+如果同步代码块中的锁，通过JIT的逃逸分析技术判定，该锁只能被一个线程访问，不可能“泄露”到外部被其他线程访问的话，JIT编译器就会取消对同步代码快的同步。
+
+```java
+public void lockEliminate(){
+        Object obj=new Object();
+        synchronized (obj){
+            // to do
+        }
+    }
+```
+
+```java
+
+经过JIT编译器逃逸技术分析优化后的效果
+public void lockEliminate(){
+        Object obj=new Object();
+        
+            // to do
+        
+    }
+```
+ 
+## 锁消除性能提升程度
+```java
+public static void main(String[] args) {
+        long start = System.currentTimeMillis();
+        for (int i = 0; i < 20000000; i++) {
+            test();
+        }
+        long end = System.currentTimeMillis();
+        System.out.println(end - start);
+    }
+
+    public static  void test(){
+        //-server  -XX:+DoEscapeAnalysis  -XX:-EliminateLocks  关闭锁消除虚拟机参数
+        //-server  -XX:+DoEscapeAnalysis  -XX:+EliminateLocks  开启锁消除虚拟机参数
+        StringBuffer stringBuffer = new StringBuffer();
+            stringBuffer.append("yan");
+
+    } 
+ ```
+在关闭虚拟机锁消除的策略下，平均耗时900nm，打开虚拟机锁消除情况下平均耗时500nm.锁消除状态下的StringBuffer性能几乎接近StringBuilder，是StringBuilder耗时的120%，但是非锁消除状态是StringBuilder耗时的210%。
+
+
+# 锁粗化
+## 产生背景
+HotSpot虚拟机还有一些额外的锁优化的技术，虽然从技术上讲它们并不属于逃逸分析子系统中的一部分，但也是通过分析作用域来提高内部锁的性能。当连续获取同一个对象的锁时，HotSpot虚拟机会去检查多个锁区域是否能合并成一个更大的锁区域。这种聚合被称作锁粗化，它能够减少加锁和解锁的消耗。
+当HotSpot 
+**JVM发现需要加锁时，它会尝试往前查找同一个对象的解锁操作。如果能匹配上，它会考虑是否要将两个锁区域作合并，并删除一组解锁/加锁操**作
+
+![对象内存布局](./imgs/第二章/锁粗话monitor.png)
+
+```java
+for(int i=0;i<100000;i++){  
+    synchronized(this){  
+        // to do 
+         }
+} 
+```
+
+```java
+编译器会对锁进行粗化为
+
+synchronized(this){  
+for(int i=0;i<100000;i++){  
+        // to do        
+} 
+}
+```
+
+# 嵌套锁
+
+同步块可能会一个嵌套一个，进而两个块使用同一个对象的监视器锁来进行同步也是很有可能的。这种情况我们称之为嵌套锁，HotSpot虚拟机是可以识别出来并删除掉内部块中的锁的。当一个线程进入外部块时就已经获取到锁了，因此当它尝试进入内部块时，肯定也仍持有这个锁，所以这个时候删除锁是可行的。
+
+在写作本文的时候，Java 8中的嵌套锁删除只有在锁被声明为static final或者锁的是this对象时才可能发生。
+
+```java
+Object object=new Object();
+        synchronized (object){
+            synchronized (object){
+                System.out.println("synchronized");
+            }
+        }
+```
+```java
+优化后的代码
+Object object=new Object();
+        synchronized (object){
+            
+                System.out.println("synchronized");
+            
+        }
+```        
+        
+        
+[jvm优化之逃逸分析及锁消除](http://ifeve.com/jvm%E4%BC%98%E5%8C%96%E4%B9%8B%E9%80%83%E9%80%B8%E5%88%86%E6%9E%90%E5%8F%8A%E9%94%81%E6%B6%88%E9%99%A4/)
\ No newline at end of file
Index: out/src/swordOffer/数组/JZ4重建二叉树.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- out/src/swordOffer/数组/JZ4重建二叉树.java	(date 1601260703470)
+++ out/src/swordOffer/数组/JZ4重建二叉树.java	(date 1601260703470)
@@ -0,0 +1,11 @@
+package swordOffer.数组;
+
+/**
+ * @author www.yanzhongxin.com
+ * @date 2020/9/24 20:17
+ */
+
+public class JZ4重建二叉树 {
+
+
+}
Index: out/src/高并发/ReentrantLockDemo.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- out/src/高并发/ReentrantLockDemo.java	(date 1604045849049)
+++ out/src/高并发/ReentrantLockDemo.java	(date 1604045849049)
@@ -0,0 +1,22 @@
+package 高并发;
+
+import java.util.concurrent.locks.ReentrantLock;
+
+/**
+ * @author www.yanzhongxin.com
+ * @date 2020/10/30 12:21
+ */
+public class ReentrantLockDemo {
+    public static void main(String[] args) {
+
+    }
+
+    public static void testReentrantlock(){
+        ReentrantLock  lock=new ReentrantLock();
+        Object ob=new Object();
+        lock.lock();
+
+
+        lock.unlock();
+    }
+}
Index: out/src/高并发/3-1 java内存模型.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- out/src/高并发/3-1 java内存模型.md	(date 1604119257102)
+++ out/src/高并发/3-1 java内存模型.md	(date 1604119257102)
@@ -0,0 +1,371 @@
+
+## 并发编程线程通信和同步
+
+### 通信
+共享内存（java）和消息传递。共享内存是读写内存中的公共状态进行通信，属于隐式通信。
+消息传递方式中，线程之间通过发消息显示通信。
+![JMM](./imgs/第三章/jmm内存模型.jpg)
+如果线程a和b通过共享内存方式进行通信，1）线程A把本地内存A中更新过的共享变量刷新到主内存中去。2）线程B到主内存中去读取线程A之前已更新过的共享变量。比如初始
+
+## 同步
+控制不同线程操作顺序，共享内存模型下，同步是显式进行的。
+
+## 源代码到最终执行指令重排序
+编译器和处理器为了提高性能常常对指令进行重排序。
+![JMM](./imgs/第三章/三种指令重排序.jpg)
+1. 编译器优化的重排序。在不改变单线程程序语义的前提下，重新安排语指令执行顺序。
+2. 指令级并行的重排序。现代处理器采用了指令级并行技术将多条指令重叠执行（五段流水中并行执行）。如果不存在数据依赖性，处理器可以改变语句对应
+机器指令的执行顺序。
+3. 内存系统的重排序。处理器使用缓存和读/写缓冲区，这使得加载（读内）和存储（写内存）操作看上去可能是在乱序执行。多数处理器都支持写-读操作重排序，因为都有cache
+
+现在的处理器为了指令流水的性能，都引入了cache，处理器对数据的更改首先刷新到cache中，并且cache都提供了write back法，把修改后的数据
+批量刷新到主存中，这也导致了一个问题就是内存可见性，每个处理器上的写缓冲区，仅仅对它所在的处理器可见。
+![cache写回法导致内存可见性问题](./imgs/第三章/cache写回法导致内存可见性问题.jpg)
+cacheA中a1把a=1写操作写入到cache中，x=b从主内存中读取b=0，后把cache中的a更新到主内存，cache B也是同样处理。处理器先执行a1后执行a2但是实际内存中执行顺序是先a2后a1，因此处理器A的内存操作顺序由于cache和wirite back算法导致指令重排了。
+
+**如何解决上述cache引起的指令重排序导致内存可见性问题呢？**
+通过a1和a2之间插入内存屏障Store-Load，执行a1时候把cache中的所有数据刷新到主存中。
+![四种内存屏障](./imgs/第三章/四种内存屏障.jpg)
+[常见的内存屏障讲解](https://www.bilibili.com/video/BV1X54y1Q75J?from=search&seid=9769013173264995151 "fa")
+
+虽然指令重排提高了性能，但是很容易导致内存可见性问题，因此jmm内存模型的重排序规则会通过内存屏障指令来禁止特定类型的处理器重排序，为程序员提供内存可见性的保证。
+
+### 禁止指令重排单线程数据依赖
+
+![数据依赖](./imgs/第三章/数据依赖.jpg)
+数据依赖仅仅针对单线程，编译器和处理器不会对指令进行重排，但是如果多线程之间的数据依赖就不能保证，比如上例中的写-读可见性问题。
+### 允许指令重排单线程as-if-serial
+as-if-serial:编译器处理器我允许你们重排，但是执行结果不能改变。
+
+```java
+double pi = 3.14; // A
+double r = 1.0; // B
+double area = pi * r * r; // C
+```
+A和C有数据依赖，B和C也有数据依赖，c不可以排序到AB之前。但是AB之间没有数据以来因此顺序可以是A->B>C也可以是B->A>C.
+**as-if-serial给程序员提供了幻觉，单线程下程序好像是顺序执行的，不用担心内存可见性。** A happen before B，MM并不要求A一定要在B之前执行。JMM仅仅要求前一个操作（执行的结果）对后一个操作可见，且前一个操作按顺序排在第二个操作之前。
+### 多线程指令重排序
+多线程重排序情况下，可能导致内存可见性问题，影响执行结果。
+```java
+class ReorderExample {
+        int a = 0; //a和flag被写入后立即被另一个线程可见。
+        boolean flag = false;//
+        public void writer() {
+        a = 1;       // 1
+        flag = true; // 2
+        }
+        public void reader() {
+        if (flag) { // 3
+        int i = a * a; // 4
+        }
+    }
+}
+```
+问题：4不一定能看到1写入的数值。
+讨论：1，2之间无数据依赖，3，4之间无数据依赖，因此编译器和处理器可以对他们进行指令重排，虽然2和3之间有数据依赖，但是这是不同的线程。
+![1，2之间指令重排](./imgs/第三章/多线程指令重排.jpg)
+![3，4之间指令重排](./imgs/第三章/多线程指令重排2.jpg)
+操作3和操作4存在控制依赖关系。编译器和处理器会采用猜测（Speculation）执行来克服控制相关性对并行度的影响，先把a*a写入硬件缓存中，如果flag为真
+后直接把硬件缓存中赋值给i。 **指令重排可能直接破坏了多线程程序语义。**
+
+## 顺序一致性
+### 顺序一致性模型
+一个被过于理想化的模型，给程序员提供了很强的内存可见性保证（禁止指令重排和数据立即刷新到主存）。
+**JMM对对内存一致性的保证**，如果程序是正确同步的，程序的执行将具有顺序一致性——即程序的执行结果与该程序在顺序一致性内存模型中的**执行结果相同（仅仅是结果，不保证不指令重排）**。如果程序非同步的，
+程序不仅整体执行无序，并且各个线程对所看到的操作也可能不一致。（比如cache导致的写-读重排序，写cache仅对当前线程可见）
+#### 特点
+1. 一个线程中的所有操作必须按照程序的顺序来执行。（**禁止指令重排**）
+2. （不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序，每个操作都必须原子执行且立刻对所有线程可见。（**数据立刻刷新到主存**）
+![happpenbefore](./imgs/第三章/顺序一致性模型.jpg)
+#### 多线程同步/非同步下的顺序一致性
+1. 线程a a1->a2->a3
+2. 线程b b1->b2->b3
+![同步](./imgs/第三章/同步顺序一致性模型.png)
+![非同步](./imgs/第三章/非同步顺序一致性模型.jpg)
+
+```java
+
+class SynchronizedExample {
+    int a = 0;
+    boolean flag = false;
+    public synchronized void writer() { // 获取锁
+    a = 1;
+    flag = true;
+    } // 释放锁
+    public synchronized void reader() { // 获取锁
+    if (flag) {
+    int i = a;
+    } // 释放锁
+    }
+}
+```
+**同步情况下顺序一致性和JMM执行流程**
+![同步](./imgs/第三章/同步下顺序一致性和JMM内存模型.jpg)
+
+**未同步情况下顺序一致性和JMM执行流程**
+对于未同步或未正确同步的多线程程序，JMM只提供最小安全性，即JMM拿到的数据不会无中生有（至少内存清零后数据初始化默认值）。
+JMM不保证未同步程序和顺序一致性一样，因为这会导致JMM对编译器处理器大量优化（数据立即可见，禁止指令重排），导致降低性能。
+
+1. 顺序一致性模型保证单线程内的操作会按程序的顺序执行，而JMM不保证单线程内的
+操作会按程序的顺序执行（比如上面正确同步的多线程程序在临界区内的重排序）。这一点前
+面已经讲过了，这里就不再赘述。
+2. 顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程
+能看到一致的操作执行顺序。（cache中读写导致的重排序）
+3. JMM不保证对64位的long型和double型变量的写操作具有原子性，而顺序一致性模型保证对所有的内存读/写操作都具有原子性。
+
+从JSR-133内存模型开始（即从JDK5开始），只允许把一个64位long/double型变量的写操作拆分为两个32位的写操作来执行，任意的读操作在JSR-
+133中都必须具有原子性（即任意读操作必须要在单个读事务中执行）
+
+## volatile内存语义
+### volatile两大特性概述
+简单理解volatile就是一把轻量锁，对volatile变量的读写操作用“锁”同步。
+```java
+class VolatileFeaturesExample {
+    volatile long vl = 0L; // 使用volatile声明64位的long型变量
+        public void set(long l) {
+        vl = l; // 单个volatile变量的写
+        }
+        public void getAndIncrement () {
+        vl++; // 复合（多个）volatile变量的读/写非原子操作
+        }
+        public long get() {
+        return vl; // 单个volatile变量的读
+        }
+}
+// “加锁等价形式”
+class VolatileFeaturesExample {
+    long vl = 0L; // 64位的long型普通变量
+    public synchronized void set(long l) { // 对单个的普通变量的写用同一个锁同步
+    vl = l;
+    }
+    public void getAndIncrement () { // 普通方法调用
+    long temp = get(); // 调用已同步的读方法
+    temp += 1L; // 普通写操作
+    set(temp); // 调用已同步的写方法
+    }
+    public synchronized long get() { // 对单个的普通变量的读用同一个锁同步
+    return vl;
+    }
+}
+```
+
+“volatile锁”根据happen-before规则，保证释放锁和获取锁线程内存的可见性（释放锁数据刷新到主存），
+同时“锁”又保证了了单个变量的读写操作时原子性。
+1. 原子性：保证单个volatile变量读写有原子性
+2. 可见性：读volatile变量的线程，立即可见其他线程对该变量的修改
+
+### volatile读写的内存语义
+
+写内存语义：写一个volatile变量时，JMM会把该线程对应的本地内存中的**所有的共享变量值刷新到主内存**。
+和锁syn的释放有相同的内存语义（lock.unlock()锁释放，共享变量刷新到主存中）
+![volatile](./imgs/第三章/volatile写内存语义.jpg)
+读内存语义：当读一个volatile变量时，JMM会把该线程对应的**本地内存所有共享变量置为无效**。线程接下来将从**主内存中读取所有（包含非volatile变量）共享变量**。
+和锁syn的获取有相同的内存语义（锁获取lock.lock()，线程从主内存中读取共享数据）
+![volatile](./imgs/第三章/volatiled读内存语义.jpg)
+
+### volatile读写的内存语义实现方式
+
+为了实现volatile读写内存的语义，需要禁止编译器，处理器进行执行重排序,禁止重排序需要插入内存屏障。
+![volatile](./imgs/第三章/volatile重排序规则.jpg)
+1. 在每个volatile写操作的前面插入一个StoreStore屏障。
+2. 在每个volatile写操作的后面插入一个StoreLoad屏障。
+3. 在每个volatile读操作的后面插入一个LoadLoad屏障。
+4. 在每个volatile读操作的后面插入一个LoadStore屏障
+
+**volatile写插入内存屏障**
+![volatile](./imgs/第三章/volatile写插入内存屏障1.jpg)
+
+**volatile读插入内存屏障**
+![volatile](./imgs/第三章/volatile写内存语义实现1.jpg)
+
+## syn锁的内存语义
+java中的锁主要用来同步的，即临界区代码（包含共享变量）互斥执行。但是锁还有另一个功能，锁的内存语义是线程通信（共享内存方式），
+即A线程锁的释放后，共享变量刷新到主内存，当线程B锁再次获取后a线程中修改后的共享数据立即被B可见，这就通过共享内存完成了从线程a到b的通信。
+
+### 锁的释放获取内存语义
+```java
+class MonitorExample {
+    int a = 0;
+    public synchronized void writer() {//加锁   // 1
+        a++;                                   // 2
+    }                                  //释放锁 // 3
+    public synchronized void reader() {//加锁  // 4
+        int i = a;                              // 5
+       }                               //释放锁 // 6
+}
+
+```
+释放锁内存语义：当线程释放锁时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。
+![syn锁释放内存语义](./imgs/第三章/syn锁释放内存语义.jpg)
+获取锁内存语义：当线程获取锁时，JMM会把该线程对应的本地内存置为无效。从而使得被监视器保护的临界区代码必须从主内存中读取共享变量。
+![syn锁释放内存语义](imgs/第三章/syn加锁内存语义.jpg)
+### 锁内存语义实现
+深入理解的话，需要阅读Reentrantlock源码
+
+1. 利用volatile变量的写-读所具有的内存语义。
+2. 利用CAS所附带的volatile读和volatile写的内存语义。
+![concurrent包实现](./imgs/第三章/concurrent包实现最底层.jpg)
+基于锁的内存语义两种实现方式，最底层java线程通信的四种方式。
+1. A线程写volatile变量，随后B线程读这个volatile变量。
+2. A线程写volatile变量，随后B线程用CAS更新这个volatile变量。
+3. A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量。
+4. A线程用CAS更新一个volatile变量，随后B线程读这个volatile变量。
+
+
+#### cas原理
+
+如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值。此操作具有volatile读和写的内存语义。
+编译器不会对volatile读与volatile读后面的任意内存操作重排序；编译器不会对volatile写与volatile写前面的任意内存操作重排序。
+因此编译器不能对CAS与CAS前面和后面的任意内存操作重排序。
+```java
+//jdk中的cas
+protected final boolean compareAndSetState(int expect, int update) {
+    return unsafe.compareAndSwapInt(this, stateOffset, expect, update);
+}
+```
+```
+     //c ++ cas实现方式
+    `inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest,
+    jint compare_value) {
+        // alternative for InterlockedCompareExchange
+        int mp = os::is_MP();
+        __asm {
+        mov edx, dest
+        mov ecx, exchange_value
+        mov eax, compare_value
+        LOCK_IF_MP(mp) //MP代表多处理器
+        cmpxchg dword ptr [edx], ecx
+    }`
+}
+```
+如果当前是多处理器MP则在cmpxchg指令前面加上lock，反之单处理器省略lock（单处理器自身会维护单处理器内的顺序一致性，不需要lock前缀提供的内存屏障禁止重排序）。
+
+lock指令作用
+
+1. 确保对内存的读-改-写操作原子执行，通过锁总线或者锁住缓存行。
+2. 禁止该指令，与之前和之后的读和写指令重排序。volatile禁止指令重排语义
+3. 把写缓冲区中的所有数据刷新到内存中。volatile写语义内存可见性
+
+## final内存语义
+### 基本用法
+1. 修饰类： 当用final修饰一个类时，表明这个类不能被继承。
+2. 修饰方法： final修饰的方法表示此方法已经是“最后的、最终的”含义，亦即此方法不能被重写
+3. 修饰变量：表示常量，只能被赋值一次，赋值后值不再改变
+
+### final域重排序
+#### 基本数据类型
+1. 在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用
+变量，这两个操作之间不能重排序。(禁止构造函数内把构造对象“逃逸”，否则可能读取到final未初始化之前的数值，下次读取就可能是初始化后的数值)
+2. 初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能
+重排序。
+
+```java
+public class FinalExample {
+    int i;　　　　　　　　　　 // 普通变量
+    final int j;　　　　　　　　 // final变量
+    static FinalExample obj;
+    public FinalExample () {　　 // 构造函数
+        i = 1;　　　　　　　　 // 写普通域
+        j = 2;　　　　　　　　 // 写final域
+        }
+    public static void writer () {　 // 写线程A执行
+        obj = new FinalExample ();
+        }
+    public static void reader () {　 // 读线程B执行
+        FinalExample object = obj; // 读对象引用
+        int a = object.i;　　　　　 // 读普通域
+        int b = object.j;　　　　　 // 读final域
+        }
+}
+```
+
+#### 引用数据类型
+除了包含上述基本数据类型的重排序规则之外，还有：在构造函数内对一个final引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给
+一个引用变量，这两个操作之间不能重排序。
+
+```java
+public class FinalReferenceExample {
+    final int[] intArray; // final是引用类型
+    static FinalReferenceExample obj;
+    public FinalReferenceExample () { // 构造函数
+        intArray = new int[1]; // 1
+        intArray[0] = 1; // 2
+        }
+    public static void writerOne () { // 写线程A执行
+        obj = new FinalReferenceExample (); // 3
+        }
+    public static void writerTwo () { // 写线程B执行
+        obj.intArray[0] = 2; // 4
+        }
+    public static void reader () { // 读线程C执行
+        if (obj != null) { // 5
+        int temp1 = obj.intArray[0]; // 6
+        }
+    }
+}
+```
+
+### 写final域重排序规则
+写final域的重排序规则禁止把final域的写重排序到构造函数之外
+1. JMM禁止编译器把final域的写重排序到构造函数之外。
+2. 编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障
+禁止处理器把final域的写重排序到构造函数之外,但是写普通域可能重排序构造函数之外。
+![final](./imgs/第三章/final写重排序.jpg)
+
+### 读final域重排序规则
+在一个线程中，1初次读对象引用与2初次读该对象包含的final域，JMM禁止处理器重排序这两个操作（注意，这个规则仅仅针对处理器）。编译器会在读final
+域操作的前面插入一个LoadLoad屏障。1,2这两个操作有间接依赖关系编译器不会进行重排序，并且多数处理器也不会对此进行重排序，但是极少数处理器会进行重排序。
+通过插入LoadLoad屏障，禁止这种处理器进行重排序。
+
+![final](./imgs/第三章/final读规则.jpg)
+
+### 处理器如何实现final域的读写重排序规则
+
+禁止特定类型的重排序都是插入内存屏障：写final域的重排序规则会要求编译器在final域的写之后，构造函数return之前插入一个StoreStore障屏。读final域的重排序规则要求编译器在读final域的操作前面插入
+一个LoadLoad屏障。
+
+## happen-before规则
+
+### JMM设计思路
+1. 程序员：对内存模型的使用。程序员希望内存模型易于理解、易于编程。程序员希望基于
+一个强内存模型（比如立刻可见，禁止重排序）来编写代码。
+2. 编译器和处理器：对内存模型的实现。编译器和处理器希望内存模型对它们的束缚越少越
+好，这样它们就可以做尽可能多的优化来提高性能。编译器和处理器希望实现一个弱内存模
+型。（指令重排，批量刷新）
+
+上述两种两种因素是相互矛盾的，因此JMM设计的核心：既要为程序员提供足够强的内存可见性保证，又要对编译器
+处理器不束缚他们。JMM在不改变单线程和正确同步的多线程结果下，怎么优化提升性能都可以（例子：锁消除）。
+
+```java
+    double pi = 3.14;　　 // A
+    double r = 1.0;　　　　 // B
+    double area = pi * r * r;　 // C
+    A happens-before B。 //非必须happen-before
+    B happens-before C。 //必须happen-before
+    A happens-before C。 //必须happen-before
+```
+JMM把happens-before要求禁止的重排序分为了下面两类.
+1. 会改变程序执行结果的重排序，JMM要求编译器和处理器必须禁止这种重排序。B happenbefore c , a happenbefore c
+2. 不会改变程序执行结果的重排序，JMM对编译器和处理器不做要求（JMM允许这种重排序）。a happenbefore b
+![happpenbefore](./imgs/第三章/happenbefore两种禁止重排序.jpg)
+
+### happenbefore定义
+1. happens-before（单/多线程都可）仅仅要求前一个操作（执行的结果）对后一个操作**可见**，且前一
+个操作按顺序排在第二个操作**之前**。（对程序员承诺）
+2. 两个操作存在happens-before关系，并不意味着必须要按照happens-before关系指定的顺序来执行（上例中a happenbefore b 也可以重排序b happenbefore a），
+如果重排序结果不影响最终结果，则jmm允许这种重排序。（对处理器编译器承诺）
+
+as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变。
+as-if-serial语义给编写单线程程序的程序员创造了一个幻境：单线程程序是按程序的顺序（重排序不影响结果）来执行的。
+happens-before关系给编写正确同步的多线程程序的程序员创造了一个幻境：正确同步的多线程程序（syn代码块内部也可以重排序）是按happens-before指定的顺序来执行的。
+
+
+一个happens-before规则对应于一个或多个编译器和处理器重排序规则。
+![happpenbefore](./imgs/第三章/happenbefore.jpg)
+1. 程序顺序规则：一个线程中的每个操作，happens-before于该线程中的任意后续操作。
+2. 监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。
+3. volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的
+读。
+4. 传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。
+
+## 双重校验和延迟初始化
Index: out/src/高并发/2-3并发编程原子操作实现原理.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- out/src/高并发/2-3并发编程原子操作实现原理.md	(date 1603802330221)
+++ out/src/高并发/2-3并发编程原子操作实现原理.md	(date 1603802330221)
@@ -0,0 +1,63 @@
+# 什么是原子操作
+
+不可被中断的一个或一系列操作
+
+## 处理器如何实现原子操作
+
+一般通过缓存cache或总线加锁的方式实现多处理器之间原子操作。
+
+### 总线加锁（重量级锁）
+
+学过计算机组成原理的话应该知道，cpu的指令周期数据流中的间址周期中，cpu和存储器之间的数据交互
+必须要通过总线（地址、数据、控制），比如cpu从存贮器地址xx0001中取出数据过程是，由mar地址传输到地址总线，CU控制单元发出控制信号开始读取。
+读取的数据经过数据总线传输到MDR中，因此cpu和存储器的数据交互必须经过总线。多cpu情况下，为了保证对存储器中某个共享变量的修改的原子性比如i++，cpu1执行i++操作时候
+使用总线锁LOCK#信号发送到总线上，其他cpu2如果想和存储器进行数据交互i++请求都会被阻塞住，因此可以保证cpu1执行i++操作的原子性。
+
+缺点：这是一把重锁，虽然可以实现原子操作，但是如果其他处理器访问的不是i++那块存储器也会被阻塞住，很明显不合理。
+
+![cpu与存储器总线数据交互](./imgs/第二章/cpu与存储器总线数据交互.jpg)
+
+
+### 缓存加锁保障原子性（轻量级锁）
+
+所谓“缓存锁定”是指内存区域如果被缓存在处理器的缓存
+行中，并且在Lock操作期间被锁定，那么当它执行锁操作回写到内存时，处理器不在总线上声
+言LOCK＃信号，而是修改内部的内存地址，并允许它的缓存一致性机制来保证操作的原子
+性，因为缓存一致性机制会阻止同时修改由两个以上处理器缓存的内存区域数据。
+
+
+
+
+
+## java如何实现原子操作
+
+主要两种方式 加锁synchronized和循环CAS方式
+
+### 加锁实现原子操作
+
+锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。
+```java
+synchronized(obj){
+    to do 1
+    to do 2
+    ....
+}
+```
+### 循环cas
+
+JVM中CAS使用了cpu的cmpxchg指令实现，不断循环执行cas直到成功为止。
+
+![cas流程](./imgs/第二章/cas.jpg)
+
+#### cas ABA问题
+如果一个值原来是A，变成了B，又变成了A，那么使用CAS进行检查时会发现它
+的值没有发生变化，但是实际上却变化了。解决： 使用版本号 1A->2B>3A
+
+#### cas循环时间开销大
+
+自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。
+**更深入的话，JVM插入pause指令，防止消耗五段流水部件，以及防止内存访问冲突引起cpu流水线清空（计算机组成原理空指令、五段流水访存冲突）。**
+
+#### cas只能保证一个变量原子
+
+对多个共享变量操作时，循环CAS就无法保证操作的原子性。解决：有两个共享变量i＝2，j=a，合并一下ij=2a，然后用CAS来操作ij。
\ No newline at end of file
Index: out/src/Python/pycharm快捷键.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- out/src/Python/pycharm快捷键.md	(date 1604032714897)
+++ out/src/Python/pycharm快捷键.md	(date 1604032714897)
@@ -0,0 +1,2 @@
+多行注释 ctrl+/
+删除一行 ctrl+del
\ No newline at end of file
Index: out/src/markdown模板格式.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- out/src/markdown模板格式.md	(date 1601529450259)
+++ out/src/markdown模板格式.md	(date 1601529450259)
@@ -0,0 +1,8 @@
+http://www.mdeditor.com/
+
+图片链接
+![markdown](url)
+
+```java
+
+```
\ No newline at end of file
Index: out/src/java基础/1面向对象.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- out/src/java基础/1面向对象.md	(date 1601533107068)
+++ out/src/java基础/1面向对象.md	(date 1601533107068)
@@ -0,0 +1,60 @@
+# 八大基本数据类型
+## 四种整形
+四种整形分别是byte,short,int,long，所占用的字节数分别是，1，2，4，8，计算机中一个字节是8bit。这四种整形都是有符号位数。
+![markdown](./img/java四种整形.jpg)
+
+[为什么byte占用一个字节8bit，可以表示-128到+127?](https://blog.csdn.net/qq_23418393/article/details/57421688)
+
+简单来说，就是计算机把byte类型中的数据在内存中表示为，机器说的补码形式，补码的规则是，整数的补码符号位为0，负数的补码符号位为1，因此剩余七位用来表示
+数据值，正数0 1111111表示+127,负数的最小值计算机内部并表示方式为 1
+0000000。推荐阅读：计算机组成原理的数据的运算与表示这一章，关于计算机内部数据的存储和表示。
+下图是四位数的补码表示
+![markdown](./img/四位数的补码表示.jpg)
+
+```java
+byte a = Byte.MAX_VALUE; #
+a+=1;
+System.out.println(a); //输出-128
+```
+上述基本类型的整数都有默认值0，注意如果是局部变量没有初始化是没有默认值。静态变量或者类的非静态变量默认值是0
+```java
+public class test {
+    private  static  int intDefault;
+    int intDefault2;
+    public static void main(String[] args) {
+        System.out.println(test.intDefault+"   "+ new test().intDefault2);
+    }
+}
+```
+### 整形数据的源码解析
+待更新
+## 两种浮点型
+![markdown](./img/两种浮点数.jpg)
+
+推荐阅读：《计算机组成原理》的数据的运算和表示这一章，IEEE 754标准的浮点数标准。
+## 一种char字符型
+char表示按个字符，通常表示字符常量，一般采用Unicode编码单元进行标识十六进制，范围\u0000到
+\uffff占用两个字节。
+## 一种boolean类型
+true or false 一般虚拟机底层实现是用int类型的1或者0表示
+
+```java
+    boolean b=true;
+    字节码层面实现如下。
+   Code:
+       0: iconst_1
+       1: istore_1
+       2: return
+```
+# 面向对象
+## 面向对象和面向过程
+
+### 平台无关性如何实现
+
+### 基于JVM实现的语言
+
+## 面向对象三大特性
+### 封装
+### 继承
+### 多态
+### 面向对象五大原则
Index: out/src/java基础/test.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- out/src/java基础/test.java	(date 1601631381110)
+++ out/src/java基础/test.java	(date 1601631381110)
@@ -0,0 +1,14 @@
+package java基础;
+
+/**
+ * @author www.yanzhongxin.com
+ * @date 2020/10/1 12:31
+ */
+public class test {
+
+    public static void main(String[] args) {
+        StringBuffer sb=new StringBuffer();
+
+
+    }
+}
Index: out/src/java基础/java字符串.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- out/src/java基础/java字符串.md	(date 1601631381443)
+++ out/src/java基础/java字符串.md	(date 1601631381443)
@@ -0,0 +1,524 @@
+# 字符串
+[可以参考hollis大神关于字符串的详解](https://www.hollischuang.com/archives/1330)
+## 字符串的不可变性
+
+不可变字符串的好处：编译器让字符串共享，jdk的设计者认为共享带来的效率提升胜过字符串拼接，修改带来的低效率。
+
+### 为什么字符串设计成不可变？
+> String是Java中一个不可变的类，所以他一旦被实例化就无法被修改。不可变类的实例一旦创建，其成员变量的值就不能被修改。不可变类有很多优势。本文总结了为什么字符串被设计成不可变的。将涉及到内存、同步和数据结构相关的知识。
+
+**字符串设计成不可变最重要目的是，安全，高效。**
+
+### 字符串可变后果
+
+**后果1.字符串常量池**
+
+>字符串池是方法区中的一部分特殊存储。当一个字符串被被创建的时候，首先会去这个字符串池中查找，如果找到，直接返回对该字符串的引用。
+>下面的代码只会在堆中创建一个字符串
+
+```java
+String string1 = "abcd";
+String string2 = "abcd";
+```
+如果字符串可变的话，当**两个引用指向指向同一个字符串时，对其中一个做修改就会影响另外一个**。
+
+![markdown](./img/字符串不可变4.jpg)
+
+**后果2.违反某些集合的设计**
+
+```java
+如果字符串可变
+HashSet<String> set = new HashSet<String>();
+set.add(new String("a"));
+set.add(new String("b"));
+set.add(new String("c"));
+
+for(String a: set)
+    a.value = "a";
+```
+>如果字符串可以被改变，那么以上用法将有可能违反Set的设计原则，因为Set要求其中的元素不可以重复。上面的代码只是为了简单说明该问题，其实String类中并没有value这个字段值。
+
+
+### 不可变好处1. hashcode不变
+
+>Java中经常会用到字符串的哈希码（hashcode）。例如，在HashMap中，字符串的不可变能保证其hashcode永远保持一致，这样就可以避免一些不必要的麻烦。这也就意味着每次在使用一个字符串的hashcode的时候不用重新计算一次，这样更加高效。
+
+```java
+private int hash;//this is used to cache hash code.
+```
+
+> 以上代码中hash变量中就保存了一个String对象的hashcode，因为String类不可变，所以一旦对象被创建，该hash值等于0，第一次执行该对象的hashcode方法时候计算hashcode，以后获取hashcode是直接返回hash,具体请看hashcode的源码。并且并发情况下获取string的hash
+> code不会导致数据异常，源码中没有加锁，自已自行分析原因。字符串一旦创建的话，就保持了其hashcode不变，因此可以作为hashmap的key。
+
+### 不可变好处2. 使用安全
+
+>String被广泛的使用在其他Java类中充当参数。比如网络连接、打开文件等操作。如果字符串可变，那么类似操作可能导致安全问题。因为某个方法在调用连接操作的时候，他认为会连接到某台机器，但是实际上并没有（其他引用同一String对象的值修改会导致该连接中的字符串内容被修改）。可变的字符串也可能导致反射的安全问题，因为他的参数也是字符串。
+
+```java
+boolean connect(string s){
+    if (!isSecure(s)) { 
+throw new SecurityException(); 
+}
+    //如果s在该操作之前被其他的引用所改变，那么就可能导致问题。   
+    causeProblem(s);
+}
+```
+
+**线程安全**
+因为不可变对象不能被改变，所以他们可以自由地在多个线程之间共享。不需要任何同步处理
+
+
+
+### 定义一个字符串
+String s = "abcd"; String s2 = s; ![markdown](./img/字符串不可变1.jpg)
+![markdown](./img/字符串不可变2.jpg)
+### 字符串连接
+s = s.concat("ef"); ![markdown](./img/字符串不可变3.jpg)
+
+### 总结
+一旦一个string对象在内存(堆)中被创建出来，他就无法被修改。特别要注意的是，String类的所有方法都没有改变字符串本身的值，都是返回了一个新的对象。
+如果你需要一个可修改的字符串，应该使用StringBuffer 或者
+StringBuilder。否则会有大量时间浪费在垃圾回收上，因为每次试图修改都有新的string对象被创建出来。
+
+## 字符串常见源码解析
+[解析来源hollis](http://47.103.216.138/archives/99)
+
+### 字符串定义
+```java
+public final class String implements java.io.Serializable, Comparable<String>, CharSequence{}
+```
+从该类的声明中我们可以看出String是final类型的，表示该类不能被继承，同时该类实现了三个接口：java.io.Serializable、 Comparable<String>、 CharSequence
+
+### 属性
+```java
+private final char value[];
+```
+这是一个字符数组，并且是final类型，他用于存储字符串内容，从fianl这个关键字中我们可以看出，String的内容一旦被初始化了是不能被更改的。 虽然有这样的例子： String s = “a”; s = “b” 但是，这并不是对s的修改，而是重新指向了新的字符串， 从这里我们也能知道，String其实就是用char[]实现的。
+
+```java
+private int hash;
+```
+
+缓存字符串的hash Code，默认值为 0
+
+```java
+private static final long serialVersionUID = -6849794470754667710L;
+private static final ObjectStreamField[] serialPersistentFields = new ObjectStreamField[0];
+```
+因为String实现了Serializable接口，所以支持序列化和反序列化支持。Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体（类）的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常(InvalidCastException)。
+
+** [该如何创建字符串，使用” “还是构造函数？](http://47.103.216.138/archives/1249) **
+
+### 构造方法
+**1.使用字符数组、字符串构造一个String(最常见的字符串构造)**
+
+我们知道，其实String就是使用字符数组（char[]）实现的。所以我们可以使用一个字符数组来创建一个String，那么这里值得注意的是，
+当我们使用字符数组创建String的时候，会用到Arrays.copyOf方法和Arrays.copyOfRange方法。这两个方法是将原有的字符数组中的内容逐一的复制到
+String中的字符数组中。同样，我们也可以用一个String类型的对象来初始化一个String。这里将直接将源String中的value和hash两个属性直接赋值给目标String。
+因为String一旦定义之后是不可以改变的，所以也就不用担心改变源String的值会影响到目标String的值。
+```java
+ 字符数组构造字符串源码
+ public String(char value[]) {
+        //这个value就是上面那个private final数组，用来存储字符串中数据，且永远不变
+        this.value = Arrays.copyOf(value, value.length); //根据原来的数组数值，拷贝一个新的数组
+        //Arrays.copyof会调用System.arraycopy方法，然后调用native方法
+    }
+    实例化一个字符串
+    char data[] = {'a', 'b', 'c'};
+    String str = new String(data);
+    使用String类型的对象初始化字符串，源码
+    public String(String original) {
+        this.value = original.value;
+        this.hash = original.hash;
+    }
+    
+```
+**2.基于StringBuffer和StringBuilder构造String(很少用)**
+
+作为String的两个“兄弟”，StringBuffer和StringBuider也可以被当做构造String的参数。
+jdk1.8注释说，通过对字符串缓冲区StringBuffer和StringBuilder的内容被复制；字符串缓冲区的后续修改不会影响新创建的字符串。
+通常使用Stringbuffer或者StringBuilder的toString()方法获取字符串可能运行得更快，通常是首选并且StringBuilder的toString
+方法没有synchronized,因此速度更快。
+```java
+ public String(StringBuffer buffer) {
+        synchronized(buffer) {
+            this.value = Arrays.copyOf(buffer.getValue(), buffer.length());
+        }
+    }
+
+    public String(StringBuilder builder) {
+        this.value = Arrays.copyOf(builder.getValue(), builder.length());
+    }
+    
+    StringBuilder的toString方法获取string
+    public String toString() {
+    // Create a copy, don't share the array
+    return new String(value, 0, count);
+     }
+    this.value = Arrays.copyOfRange(value, offset, offset+count);
+```
+
+**3.被特殊保护的构造方法**
+
+
+```java
+String(char[] value, boolean share) {
+    // assert share : "unshared not supported";
+    this.value = value;
+}
+```
+jdk官方文档说这是包私有的构造器（因为构造器权限修饰符为default
+同一个包或者本类可以访问），有这个构造器的原因是因为速度快（数组共享，直接引用赋值）
+并且share只能是true，加share 的原因是因为我们已经有一个公开的构造器，
+String(char[] value)，并且这个公开的构造器是调用Arrays.copy复制的。
+**加入这个share的只是为了区分于String(char[] value)方法，** 
+
+- 性能好：这个很简单，一个是直接给数组赋值（相当于直接将 String 的 value 的指针指向char[]数组），一个是逐一拷贝，当然是直接赋值快了。
+- 节约内存：该方法之所以设置为
+  default，是因为一旦该方法设置为公有，在外面可以访问的话，如果构造方法没有对 arr
+  进行拷贝，那么其他人就可以在字符串外部修改该数组，由于它们引用的是同一个数组，因此对
+  arr 的修改就相当于修改了字符串，那就破坏了字符串的不可变性。
+- 安全的：对于调用他的方法来说，由于无论是原字符串还是新字符串，其 value 数组本身都是 String 对象的私有属性，从外部是无法访问的，因此对两个字符串来说都很安全。
+
+
+**如果该构造器共有的话，就破坏了字符串的不可变性**
+
+```java
+如果该构造器共有,由于该构造方法是共享数组，因此如果外部数组修改，则该字符串也会改变。
+        char data[] = {'a', 'b', 'c'};
+        String str = new String(data,true);
+        data[0]='d';
+```
+**那么该构造器到底具体应用在哪里提升了性能，解决了内存呢？** 
+
+```java
+String类的concat源码
+ public String concat(String str) {
+        int otherLen = str.length();
+        if (otherLen == 0) {
+            return this;
+        }
+        int len = value.length;
+        char buf[] = Arrays.copyOf(value, len + otherLen);//
+        str.getChars(buf, len);
+        return new String(buf, true);//这里没有使用new String(buf)，因此少了一次数组内存分配和数值拷贝。提升性能。
+    }
+    例子使用：
+        String str=new String("ABC");
+        String abc = str.concat("abc");
+        System.out.println(abc);
+
+```
+字符串的连接一般设计思路
+
+1. 先分配好所需的内存数组长度 =oldlenth+otherlenth
+1. 复制旧的数组到新的数组中。 
+1. 复制新增的字符串到新数组中。
+1. 利用String类的构造器初始化新的数组。
+
+jdk的设计者为了提升String类concat的连接性能，直接把新数组的value指向了第三步的新数组。节约了一次数组内存分配，提高了性能。因此
+jdk的操刀者可谓是每行代码都很经典。这种性能的提升，不会导致大量空间不被使用，因此不会导致内存溢出。
+
+
+### 检测字符串相等equals()
+
+```java
+ equals源码，重写了Object类的equals方法，Object.equals只是使用==号进行比较。
+ public boolean equals(Object anObject) {
+        if (this == anObject) {
+            return true;
+        }
+        if (anObject instanceof String) {
+            String anotherString = (String)anObject;
+            int n = value.length;
+            if (n == anotherString.value.length) {
+                char v1[] = value;
+                char v2[] = anotherString.value;
+                int i = 0;
+                while (n-- != 0) {
+                    if (v1[i] != v2[i])
+                        return false;
+                    i++;
+                }
+                return true;
+            }
+        }
+        return false;
+    }
+```
+1. 该方法首先判断this == anObject ？，也就是说判断要比较的对象和当前对象是不是同一个对象，如果是直接返回true，如不是再继续比较
+1. 然后在判断anObject是不是String类型的，如果不是，直接返回false,如果是再继续比较
+1. 到了能终于比较字符数组的时候，他还是先比较了两个数组的长度，不一样直接返回false，一样再逐一**逆序**比较值。
+
+### String类中的hashCode
+
+保证：相同的字符串hashcode一定一样，不同的字符串hashcode可能一样
+```java
+hashcode原本是Object类中的方法，在String类中被重写。
+//计算公式s[0]*31^(n-1) + s[1]*31^(n-2) + ... + s[n-1]
+public int hashCode() {
+        int h = hash;
+        //第一次string对象调用hashcode,h=0因为 h是成员变量，new String没有初始化
+        //默认是0，等以后初始化后，h!=0，不是第一次获取hashcode因此直接返回hashcode
+        
+        if (h == 0 && value.length > 0) { 
+            char val[] = value;
+
+            for (int i = 0; i < value.length; i++) {
+                h = 31 * h + val[i];
+            }
+            hash = h;
+        }
+        return h;
+    }
+    
+    
+```
+s[i]是string的第i个字符，n是String的长度。那为什么这里用31，而不是其它数呢?
+计算机的乘法涉及到移位计算。当一个数乘以2时，就直接拿该数左移一位即可！选择31原因是因为31是一个素数！
+所谓素数：
+质数又称素数。指在一个大于1的自然数中，除了1和此整数自身外，没法被其他自然数整除的数。
+在存储数据计算hash地址的时候，我们希望尽量减少有同样的hash地址，所谓“冲突”。如果使用相同hash地址的数据过多，那么这些数据所组成的hash链就更长，从而降低了查询效率！所以在选择系数的时候要选择尽量长的系数并且让乘法尽量不要溢出的系数，因为如果计算出来的hash地址越大，所谓的“冲突”就越少，查找起来效率也会提高。
+
+31可以 由i*31== (i<<5)-1来表示，现在很多虚拟机里面都有做相关优化，使用31的原因可能是为了更好的分配hash地址，并且31只占用5bits！
+
+在java乘法中如果数字相乘过大会导致溢出的问题，从而导致数据的丢失.
+
+而31则是素数（质数）而且不是很长的数字，最终它被选择为相乘的系数的原因不过与此！
+在Java中，整型数是32位的，也就是说最多有2^32= 4294967296个整数，将任意一个字符串，经过hashCode计算之后，
+得到的整数应该在这4294967296数之中。那么，最多有 4294967297个不同的字符串作hashCode之后，肯定有两个结果是一样的, 
+**hashCode可以保证相同的字符串的hash值肯定相同，但是，hash值相同并不一定是value值就相同**。
+
+### intern方法(美团技术文章)
+
+[深入理解intern方法，美团技术文章，挺深的，需要接虚拟机内存知识](https://tech.meituan.com/2014/03/06/in-depth-understanding-string-intern.html)
+
+```java
+public native String intern();
+```
+该方法返回一个字符串对象的内部化引用。
+众所周知：**String类维护一个初始为空的字符串的对象池**，当intern方法被调用时，如果对象池中已经包含这一个相等的字符串对象则返回对象池中的实例，否则添加字符串到对象池并返回该字符串的引用。
+如果两个字符串s1.intern()==s2.intern()等于true,当且仅当s1.equals(s2);保证了如果内容相同的字符串返回同样的常量池string引用。
+
+### String对“+”的重载
+我们知道，Java是不支持重载运算符，String的“+”是java中唯一的一个重载运算符，那么java使如何实现这个加号的呢？我们先看一段代码：
+```java
+public static void main(String[] args) { String string="hollis"; String
+string2 = string + "chuang"; } 
+
+反编译结果
+public static void main(String args[]){
+   String string = "hollis";
+   String string2 = (new StringBuilder(String.valueOf(string))).append("chuang").toString();
+}
+```
+看了反编译之后的代码我们发现，其实String对“+”的支持其实就是使用了StringBuilder以及他的append、toString两个方法。
+
+**IDEA 反编译，通过右键.java文件，show bytecode outline出现cfrDecomplie**
+
+### "高性能"的subString带来的内存溢出
+
+
+## jdk1.6和1.7如何实现subString
+
+```java
+代码例子 
+String s="abc".substring(0,2); 
+System.out.println(s);输出ab
+```
+### jdk1.6subString可能导致内存泄漏
+什么是内存泄漏？为对象分配了内存，却不能回收。**简单说1.6版本下内存泄漏是**：初始分配一个很大的字符串bigString，调用subString方法截取很小一部分smallString呢，由于1.6版本写subString是数组共享，bigString和smallString
+其实都是指向同一个字符数组（bigString），只是两个字符串的beginIndex和count不同，因此导致大字符串bigString所占用的大内存是放不掉，导致内存泄漏。
+
+**jdk1.6下源码分析**
+>String是通过字符数组实现的。在jdk 6 中，String类包含三个成员变量：char value[]， int offset，int count。他们分别用来存储真正的字符数组，数组的第一个位置索引以及字符串中包含的字符个数。
+>当调用substring方法的时候，会创建一个新的string对象，但是这个string的值仍然指向堆中的同一个字符数组。这两个对象中只有count和offset
+>的值是不同的。
+
+![markdown](./img/jdk6下subString.jpg)
+
+```java
+jdk1.6 subString源码
+String(int offset, int count, char value[]) {
+    this.value = value; //jdk1.6下设计者为了共享数组，直接对数组的引用进行赋值，聪明反被聪明误，导致了内存泄漏。
+    this.offset = offset;
+    this.count = count;
+}
+
+public String substring(int beginIndex, int endIndex) {
+    //check boundary
+    return  new String(offset + beginIndex, endIndex - beginIndex, value);
+}
+```
+
+### jdk1.7设计者解决subString导致的内存泄漏
+**简单来说就是：**subString获取的smallString不在引用bigString数组，而是从bigString中拷贝部分新的数组。
+
+![markdown](./img/jdk7subString解决.jpg)
+
+```java
+jdk1.7 subString源码
+public String(char value[], int offset, int count) {
+    //check boundary
+    //求字串直接复制，父串中的一部分，一个新的小数组。
+    this.value = Arrays.copyOfRange(value, offset, offset + count);
+}
+
+public String substring(int beginIndex, int endIndex) {
+    //check boundary
+    int subLen = endIndex - beginIndex;
+    return new String(value, beginIndex, subLen);
+}
+```
+
+## switch对String的支持
+
+jdk1.7中，switch中参数支持对byte,short,int,char,**string**,**switch参数只支持整形**。
+
+### 一、switch对整型支持的实现
+
+```java
+public class switchDemoInt {
+    public static void main(String[] args) {
+        int a = 5;
+        switch (a) {
+        case 1:
+            System.out.println(1);
+            break;
+        case 5:
+            System.out.println(5);
+            break;
+        default:
+            break;
+        }
+    }
+}
+```
+```java
+利用cfrDecompile进行反编译
+public class test {
+    public static void main(String[] args) {
+        int a = 5;
+        switch (a) {
+            case 97: {
+                System.out.println((int)1);
+                break;
+            }
+            case 5: {
+                System.out.println((int)5);
+                break;
+            }
+        }
+    }
+}
+```
+我们发现，反编译后的代码和之前的代码比较除了多了两行注释以外没有任何区别，那么我们就知道，switch对int的判断是直接比较整数的值。
+
+### 二、switch对字符支持的实现
+
+```java
+直接上代码：
+
+public class switchDemoInt {
+    public static void main(String[] args) {
+        char a = 'b';
+        switch (a) {
+        case 'a':
+            System.out.println('a');
+            break;
+        case 'b':
+            System.out.println('b');
+            break;
+        default:
+            break;
+        }
+    }
+}
+编译后的代码如下： 
+public class switchDemoChar
+{
+    public switchDemoChar()
+    {
+    }
+    public static void main(String args[])
+    {
+        char a = 'b';
+        switch(a)
+        {
+        case 97: // 'a'
+            System.out.println('a');
+            break;
+        case 98: // 'b'
+            System.out.println('b');
+            break;
+        }
+  }
+}
+```
+通过以上的代码作比较我们发现：对char类型进行比较的时候，实际上比较的是ascii码，编译器会把char型变量转换成对应的int型变量
+
+### 三、switch对字符串支持的实现（jdk1.7之后）
+
+简单来说就是先计算switch(str)参数的hashcode（string类的hashcode返回的是int数值），作为int参数传入，然后再case中str也计算hashcode后，调用str的equals方法进行比较字符串数值之不是相等，因为hashcode相等字符串不一定相等。
+
+
+```java
+还是先上代码：
+
+public class switchDemoString {
+    public static void main(String[] args) {
+        String str = "world";
+        switch (str) {
+        case "hello":
+            System.out.println("hello");
+            break;
+        case "world":
+            System.out.println("world");
+            break;
+        default:
+            break;
+        }
+    }
+}
+对代码进行反编译：
+
+public class switchDemoString
+{
+    public switchDemoString()
+    {
+    }
+    public static void main(String args[])
+    {
+        String str = "world";
+        String s;
+        switch((s = str).hashCode())
+        {
+        default:
+            break;
+        case 99162322:
+            if(s.equals("hello"))
+                System.out.println("hello");
+            break;
+        case 113318802:
+            if(s.equals("world"))
+                System.out.println("world");
+            break;
+        }
+    }
+}
+```
+>看到这个代码，你知道原来字符串的switch是通过equals()和hashCode()方法来实现的。记住，switch中只能使用整型，比如byte。short，char(ackii码是整型)以及int。还好hashCode()方法返回的是int，而不是long。通过这个很容易记住hashCode返回的是int这个事实。仔细看下可以发现，进行switch的实际是哈希值，然后通过使用equals方法比较进行安全检查，这个检查是必要的，因为哈希可能会发生碰撞。因此它的性能是不如使用枚举进行switch或者使用纯整数常量，但这也不是很差。因为Java编译器只增加了一个equals方法，如果你比较的是字符串字面量的话会非常快，比如”abc” ==”abc”。如果你把hashCode()方法的调用也考虑进来了，那么还会再多一次的调用开销，因为字符串一旦创建了，它就会把哈希值缓存起来。因此如果这个siwtch语句是用在一个循环里的，比如逐项处理某个值，或者游戏引擎循环地渲染屏幕，这里hashCode()方法的调用开销其实不会很大。
+
+**总结：switch中的参数只支持整形int,其余类型都被化为int**
+
+## 关于string的经典面试题
+
+[请参考hollis大神写的博客](https://www.hollischuang.com/archives/2517)
+
+## 本节比较难理解的部分（未看完）
+1.美团技术点评关于intern的文章 
+
+2.上述的面试题
+
+## StringBuffer与StringBuilder的爱恨情仇，面试必问（待更新）
+
Index: out/src/中间件/redis/redis数据结构sds源码解析.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- out/src/中间件/redis/redis数据结构sds源码解析.md	(date 1601220920909)
+++ out/src/中间件/redis/redis数据结构sds源码解析.md	(date 1601220920909)
@@ -0,0 +1,159 @@
+# redis3.0版本sds相关源码解析
+## string结构体设计
+
+
+```
+struct sdshdr {
+    // buf 中已占用空间的长度
+    int len;
+    // buf 中剩余可用空间的长度
+    int free;
+    // 实际string数据存储空间
+    char buf[];
+};
+类型别名，用于指向 sdshdr 的 buf 属性
+typedef char *sds;
+```
+## redis获取字符串长度底层实现
+
+```
+T = O(1) 时间复杂度
+
+static inline size_t sdslen(const sds s) {
+    sh是结构体指针，指向存储string的结构体。
+    s是指向结构体内部数据存储空间的数组，通过s指针代表结构体字符串数组的地址，
+    减去结构体的大小即是结构体的地址
+    struct sdshdr *sh = (void*)(s-(sizeof(struct sdshdr)));
+    return sh->len;
+}
+```
+
+## redis分配一个新的字符串
+
+
+```
+输入一个字符串指针init 指向字符串
+/*
+ * 根据给定字符串 init ，创建一个包含同样字符串的 sds
+ * 参数
+ *  init ：如果输入为 NULL ，那么创建一个空白 sds
+ *         否则，新创建的 sds 中包含和 init 内容相同字符串
+ * 返回值
+ *  sds ：创建成功返回 sdshdr 相对应的 sds
+ *        创建失败返回 NULL
+ * 复杂度
+ *  T = O(N)
+ */
+输入:字符串指针，返回：buffer数组的字符串指针
+sds sdsnew(const char *init) {
+    size_t initlen = (init == NULL) ? 0 : strlen(init);
+    return sdsnewlen(init, initlen);
+}
+分配一个sds结构体指针，利用zmalloc函数分配结构体内存
+已使用len设置0，剩余free为length，buff数组最后一个位置设置为 \0 字符串结束标识符
+返回指向buff数组的字符指针
+sds sdsnewlen(const void *init, size_t initlen) {
+    struct sdshdr *sh;
+    // 根据是否有初始化内容，选择适当的内存分配方式
+    // T = O(N)
+    if (init) {
+        // zmalloc 不初始化所分配的内存
+        sh = zmalloc(sizeof(struct sdshdr)+initlen+1);
+    } else {
+        // zcalloc 将分配的内存全部初始化为 0
+        sh = zcalloc(sizeof(struct sdshdr)+initlen+1);
+    }
+    // 内存分配失败，返回
+    if (sh == NULL) return NULL;
+    // 设置初始化initlen长度
+    sh->len = ;
+    // 新 sds 不预留任何空间
+    sh->free = 0;
+    // 如果有指定初始化内容，将它们复制到 sdshdr 的 buf 中
+    // T = O(N)
+    if (initlen && init)
+        memcpy(sh->buf, init, initlen);
+    // 以 \0 结尾
+    sh->buf[initlen] = '\0';
+    // 返回 buf 部分，而不是整个 sdshdr
+    return (char*)sh->buf;
+}
+```
+## 中间件.redis“释放”给定的sds结构体
+
+```
+/*
+ * 彻底释放结构体的内存 free(realptr)
+ * 复杂度
+ *  T = O(N)/
+void sdsfree(sds s) {
+    if (s == NULL) return;
+    zfree(s-sizeof(struct sdshdr));// 给出结构体的内存地址
+}
+zfree中调用 update_zmalloc_stat_free(oldsize+PREFIX_SIZE);
+free(realptr);释放结构体内存
+
+```
+
+
+```
+/*
+ * 在不释放 SDS 的字符串空间的情况下，
+ * 重置 SDS 所保存的字符串为空字符串。
+ * 复杂度
+ *  T = O(1)
+ */
+取出sds,重置长度为0，剩余长度为旧free+旧len，惰性释放，方便后来更改字符串
+并不是真正释放这个结构体的存储空间，
+void sdsclear(sds s) {
+    // 取出 sdshdr
+    struct sdshdr *sh = (void*) (s-(sizeof(struct sdshdr)));
+    // 重新计算属性
+    sh->free += sh->len;
+    sh->len = 0;
+    // 将结束符放到最前面（相当于惰性地删除 buf 中的内容）
+    sh->buf[0] = '\0';
+}
+```
+
+## sds字符串追加操作
+
+```
+sds sdscatsds(sds s, const sds t) {
+    return sdscatlen(s, t, sdslen(t));
+}
+
+ * 将长度为 len 的字符串 t 追加到 sds 的字符串末尾
+ * 返回值
+ * sds ：追加成功返回新 sds ，失败返回 NULL
+ * 复杂度
+ *  T = O(N)
+ 追加思路：
+ 1.确认剩余buff空间 =len，能够存下新的字符串，否则扩容
+ 2.使用c语言的内存拷贝函数，memcpy(void *destin, void *source, unsigned n),
+ 从destin地址开始拷贝新的字符串
+ 3. 修改旧的sds结构体的len和free数值，buff尾部\0保证字符串结束
+sds sdscatlen(sds s, const void *t, size_t len) {
+    struct sdshdr *sh;
+    size_t curlen = sdslen(s);
+    // 扩展 sds 空间
+    // T = O(N)
+    //对 sds 中 buf 的长度进行扩展，确保在函数执行之后，buf 至少会有 addlen + 1 长度的空余空间
+    如果剩余空间free大于新增加字符串len的话，直接返回旧的sds，否则的话一般扩容新长度newlength=(旧length+新增的字符串长度len)*2
+    s = sdsMakeRoomFor(s,len);
+    // 内存不足？直接返回
+    if (s == NULL) return NULL;
+    // 复制 t 中的内容到字符串后部
+    // T = O(N)
+    sh = (void*) (s-(sizeof(struct sdshdr)));
+    memcpy(s+curlen, t, len);
+    // 更新属性
+    sh->len = curlen+len;
+    sh->free = sh->free-len;
+    // 添加新结尾符号
+    s[curlen+len] = '\0';
+    // 返回新 sds
+    return s;
+}
+```
+`********`
\ No newline at end of file
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"8f17b446-9a9d-4c34-af35-b3bc752ad62e\" name=\"Default\" comment=\"\">\r\n      <change afterPath=\"$PROJECT_DIR$/out/src/Python/机器学习/numpy入门/numpy入门.md\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"Class\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"FindInProjectRecents\">\r\n    <findStrings>\r\n      <find>new String(value</find>\r\n      <find>concat(String</find>\r\n      <find>author</find>\r\n      <find>substring(</find>\r\n      <find>hash</find>\r\n    </findStrings>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"ProjectId\" id=\"1jS1JTXgVmtOQzHXx0z2N4LP045\" />\r\n  <component name=\"ProjectLevelVcsManager\" settingsEditedManually=\"true\">\r\n    <ConfirmationsSetting value=\"2\" id=\"Add\" />\r\n  </component>\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">\r\n    <property name=\"WebServerToolWindowFactoryState\" value=\"false\" />\r\n    <property name=\"aspect.path.notification.shown\" value=\"true\" />\r\n    <property name=\"last_opened_file_path\" value=\"$PROJECT_DIR$\" />\r\n    <property name=\"project.structure.last.edited\" value=\"SDKs\" />\r\n    <property name=\"project.structure.proportion\" value=\"0.15\" />\r\n    <property name=\"project.structure.side.proportion\" value=\"0.2\" />\r\n    <property name=\"settings.editor.selected.configurable\" value=\"editor.preferences.fonts.default\" />\r\n  </component>\r\n  <component name=\"RecentsManager\">\r\n    <key name=\"MoveFile.RECENT_KEYS\">\r\n      <recent name=\"D:\\大学课件\\springboot博客\\CS-Interview\\out\\src\" />\r\n      <recent name=\"D:\\大学课件\\springboot博客\\CS-Interview\\out\\src\\java基础\" />\r\n      <recent name=\"D:\\大学课件\\springboot博客\\CS-Interview\" />\r\n      <recent name=\"D:\\大学课件\\springboot博客\\CS-Interview\\out\" />\r\n    </key>\r\n    <key name=\"CopyFile.RECENT_KEYS\">\r\n      <recent name=\"D:\\大学课件\\springboot博客\\CS-Interview\\out\\src\\高并发\\imgs\\第二章\" />\r\n      <recent name=\"D:\\大学课件\\springboot博客\\CS-Interview\\out\\src\\java基础\\img\" />\r\n    </key>\r\n  </component>\r\n  <component name=\"RunManager\" selected=\"Application.JZ1数组中重复的数字\">\r\n    <configuration name=\"JZ1数组中重复的数字\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"swordOffer.数组.JZ1数组中重复的数字\" />\r\n      <module name=\"面试\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"swordOffer.数组.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"Main\" type=\"Application\" factoryName=\"Application\" temporary=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"Main\" />\r\n      <module name=\"面试\" />\r\n      <option name=\"VM_PARAMETERS\" value=\"-XX:+EliminateNestedLocks\" />\r\n      <option name=\"WORKING_DIRECTORY\" value=\"file://$PROJECT_DIR$\" />\r\n      <RunnerSettings RunnerId=\"Run\" />\r\n      <ConfigurationWrapper RunnerId=\"Run\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"test\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"java基础.test\" />\r\n      <module name=\"面试\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"java基础.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <list>\r\n      <item itemvalue=\"Application.JZ1数组中重复的数字\" />\r\n      <item itemvalue=\"Application.Main\" />\r\n      <item itemvalue=\"Application.test\" />\r\n    </list>\r\n    <recent_temporary>\r\n      <list>\r\n        <item itemvalue=\"Application.test\" />\r\n        <item itemvalue=\"Application.Main\" />\r\n        <item itemvalue=\"Application.JZ1数组中重复的数字\" />\r\n      </list>\r\n    </recent_temporary>\r\n  </component>\r\n  <component name=\"SbtLocalSettings\">\r\n    <option name=\"externalProjectsViewState\">\r\n      <projects_view />\r\n    </option>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"SvnConfiguration\">\r\n    <configuration />\r\n  </component>\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"8f17b446-9a9d-4c34-af35-b3bc752ad62e\" name=\"Default\" comment=\"\" />\r\n      <created>1595582674953</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1595582674953</updated>\r\n      <workItem from=\"1595582680057\" duration=\"4000\" />\r\n      <workItem from=\"1595582755680\" duration=\"2208000\" />\r\n      <workItem from=\"1596071020827\" duration=\"47000\" />\r\n      <workItem from=\"1599576030085\" duration=\"2925000\" />\r\n      <workItem from=\"1599628806578\" duration=\"4058000\" />\r\n      <workItem from=\"1599818010974\" duration=\"900000\" />\r\n      <workItem from=\"1599837924594\" duration=\"49000\" />\r\n      <workItem from=\"1599877720807\" duration=\"16000\" />\r\n      <workItem from=\"1599889963512\" duration=\"1073000\" />\r\n      <workItem from=\"1600949681955\" duration=\"168000\" />\r\n      <workItem from=\"1601220751149\" duration=\"170000\" />\r\n      <workItem from=\"1601259528126\" duration=\"2882000\" />\r\n      <workItem from=\"1601391454819\" duration=\"254000\" />\r\n      <workItem from=\"1601391740114\" duration=\"2397000\" />\r\n      <workItem from=\"1601431853289\" duration=\"252000\" />\r\n      <workItem from=\"1601432330292\" duration=\"2996000\" />\r\n      <workItem from=\"1601526702409\" duration=\"10275000\" />\r\n      <workItem from=\"1601561610650\" duration=\"7101000\" />\r\n      <workItem from=\"1601598744332\" duration=\"4418000\" />\r\n      <workItem from=\"1601603487534\" duration=\"53000\" />\r\n      <workItem from=\"1601603610837\" duration=\"7221000\" />\r\n      <workItem from=\"1601625760259\" duration=\"5257000\" />\r\n      <workItem from=\"1603713348909\" duration=\"1101000\" />\r\n      <workItem from=\"1603714661342\" duration=\"288000\" />\r\n      <workItem from=\"1603717124476\" duration=\"4062000\" />\r\n      <workItem from=\"1603760987789\" duration=\"1714000\" />\r\n      <workItem from=\"1603782615488\" duration=\"1181000\" />\r\n      <workItem from=\"1603797414558\" duration=\"5063000\" />\r\n      <workItem from=\"1603893707213\" duration=\"8000\" />\r\n      <workItem from=\"1604022770754\" duration=\"2217000\" />\r\n      <workItem from=\"1604045148269\" duration=\"212000\" />\r\n      <workItem from=\"1604045524682\" duration=\"94000\" />\r\n      <workItem from=\"1604051212488\" duration=\"13996000\" />\r\n      <workItem from=\"1604108953584\" duration=\"8426000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"first time git commit\">\r\n      <created>1595583006825</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1595583006825</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"新增markdown文件\">\r\n      <created>1595583319524</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1595583319524</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"新增一篇文章sds\">\r\n      <created>1595583481495</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1595583481495</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00004\" summary=\"新增一篇文章sds\">\r\n      <created>1595583681034</created>\r\n      <option name=\"number\" value=\"00004\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1595583681034</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00005\" summary=\"最新提交\">\r\n      <created>1599818056097</created>\r\n      <option name=\"number\" value=\"00005\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1599818056097</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00006\" summary=\"最新提交\">\r\n      <created>1599818216955</created>\r\n      <option name=\"number\" value=\"00006\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1599818216955</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00007\" summary=\"增加博客网址\">\r\n      <created>1599837970350</created>\r\n      <option name=\"number\" value=\"00007\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1599837970350</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00008\" summary=\"增加博客网址\">\r\n      <created>1599892067837</created>\r\n      <option name=\"number\" value=\"00008\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1599892067838</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00009\" summary=\"新增了syn的锁消除，粗化，嵌套所，自旋锁\">\r\n      <created>1603721054582</created>\r\n      <option name=\"number\" value=\"00009\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00009\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1603721054582</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"10\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"UnknownFeatures\">\r\n    <option featureType=\"com.intellij.fileTypeFactory\" implementationName=\"*.md\" />\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <MESSAGE value=\"first time git commit\" />\r\n    <MESSAGE value=\"新增markdown文件\" />\r\n    <MESSAGE value=\"新增一篇文章sds\" />\r\n    <MESSAGE value=\"最新提交\" />\r\n    <MESSAGE value=\"增加博客网址\" />\r\n    <MESSAGE value=\"新增了syn的锁消除，粗化，嵌套所，自旋锁\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"新增了syn的锁消除，粗化，嵌套所，自旋锁\" />\r\n  </component>\r\n  <component name=\"WindowStateProjectService\">\r\n    <state x=\"261\" y=\"0\" key=\"#Plugins\" timestamp=\"1604045348714\">\r\n      <screen x=\"0\" y=\"0\" width=\"1536\" height=\"824\" />\r\n    </state>\r\n    <state x=\"261\" y=\"0\" key=\"#Plugins/0.0.1536.824@0.0.1536.824\" timestamp=\"1604045348714\" />\r\n    <state width=\"738\" height=\"116\" key=\"GridCell.Tab.0.bottom\" timestamp=\"1603784671620\">\r\n      <screen x=\"0\" y=\"0\" width=\"1536\" height=\"824\" />\r\n    </state>\r\n    <state width=\"738\" height=\"116\" key=\"GridCell.Tab.0.bottom/0.0.1536.824@0.0.1536.824\" timestamp=\"1603784671620\" />\r\n    <state width=\"738\" height=\"116\" key=\"GridCell.Tab.0.center\" timestamp=\"1603784671620\">\r\n      <screen x=\"0\" y=\"0\" width=\"1536\" height=\"824\" />\r\n    </state>\r\n    <state width=\"738\" height=\"116\" key=\"GridCell.Tab.0.center/0.0.1536.824@0.0.1536.824\" timestamp=\"1603784671620\" />\r\n    <state width=\"738\" height=\"116\" key=\"GridCell.Tab.0.left\" timestamp=\"1603784671620\">\r\n      <screen x=\"0\" y=\"0\" width=\"1536\" height=\"824\" />\r\n    </state>\r\n    <state width=\"738\" height=\"116\" key=\"GridCell.Tab.0.left/0.0.1536.824@0.0.1536.824\" timestamp=\"1603784671620\" />\r\n    <state width=\"738\" height=\"116\" key=\"GridCell.Tab.0.right\" timestamp=\"1603784671620\">\r\n      <screen x=\"0\" y=\"0\" width=\"1536\" height=\"824\" />\r\n    </state>\r\n    <state width=\"738\" height=\"116\" key=\"GridCell.Tab.0.right/0.0.1536.824@0.0.1536.824\" timestamp=\"1603784671620\" />\r\n    <state x=\"153\" y=\"0\" key=\"SettingsEditor\" timestamp=\"1604051814907\">\r\n      <screen x=\"0\" y=\"0\" width=\"1536\" height=\"824\" />\r\n    </state>\r\n    <state x=\"153\" y=\"0\" key=\"SettingsEditor/0.0.1536.824@0.0.1536.824\" timestamp=\"1604051814907\" />\r\n    <state x=\"341\" y=\"183\" key=\"run.anything.popup\" timestamp=\"1604056498660\">\r\n      <screen x=\"0\" y=\"0\" width=\"1536\" height=\"824\" />\r\n    </state>\r\n    <state x=\"341\" y=\"183\" key=\"run.anything.popup/0.0.1536.824@0.0.1536.824\" timestamp=\"1604056498660\" />\r\n    <state x=\"347\" y=\"0\" width=\"840\" height=\"1034\" key=\"search.everywhere.popup\" timestamp=\"1604118932947\">\r\n      <screen x=\"0\" y=\"0\" width=\"1536\" height=\"824\" />\r\n    </state>\r\n    <state x=\"347\" y=\"0\" width=\"840\" height=\"1034\" key=\"search.everywhere.popup/0.0.1536.824@0.0.1536.824\" timestamp=\"1604118932947\" />\r\n  </component>\r\n  <component name=\"XDebuggerManager\">\r\n    <breakpoint-manager>\r\n      <breakpoints>\r\n        <line-breakpoint enabled=\"true\" type=\"java-line\">\r\n          <url>file://$PROJECT_DIR$/out/src/swordOffer/数组/JZ1数组中重复的数字.java</url>\r\n          <line>62</line>\r\n        </line-breakpoint>\r\n        <line-breakpoint enabled=\"true\" type=\"java-line\">\r\n          <url>file://$PROJECT_DIR$/out/src/swordOffer/数组/JZ1数组中重复的数字.java</url>\r\n          <line>36</line>\r\n          <option name=\"timeStamp\" value=\"1\" />\r\n        </line-breakpoint>\r\n        <line-breakpoint enabled=\"true\" type=\"java-line\">\r\n          <url>file://$PROJECT_DIR$/out/src/swordOffer/数组/JZ1数组中重复的数字.java</url>\r\n          <line>39</line>\r\n          <option name=\"timeStamp\" value=\"2\" />\r\n        </line-breakpoint>\r\n        <line-breakpoint enabled=\"true\" type=\"java-line\">\r\n          <url>file://$PROJECT_DIR$/out/src/swordOffer/数组/JZ1数组中重复的数字.java</url>\r\n          <line>50</line>\r\n          <option name=\"timeStamp\" value=\"3\" />\r\n        </line-breakpoint>\r\n        <line-breakpoint enabled=\"true\" type=\"java-line\">\r\n          <url>file://$PROJECT_DIR$/out/src/swordOffer/数组/JZ1数组中重复的数字.java</url>\r\n          <line>54</line>\r\n          <option name=\"timeStamp\" value=\"5\" />\r\n        </line-breakpoint>\r\n        <line-breakpoint enabled=\"true\" type=\"java-method\">\r\n          <url>file://$PROJECT_DIR$/out/src/swordOffer/数组/JZ1数组中重复的数字.java</url>\r\n          <line>48</line>\r\n          <properties class=\"swordOffer.数组.JZ1数组中重复的数字\" method=\"swap\">\r\n            <option name=\"EMULATED\" value=\"true\" />\r\n          </properties>\r\n          <option name=\"timeStamp\" value=\"4\" />\r\n        </line-breakpoint>\r\n      </breakpoints>\r\n    </breakpoint-manager>\r\n  </component>\r\n  <component name=\"antWorkspaceConfiguration\">\r\n    <option name=\"IS_AUTOSCROLL_TO_SOURCE\" value=\"false\" />\r\n    <option name=\"FILTER_TARGETS\" value=\"false\" />\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- .idea/workspace.xml	(revision 309b2bd0343897240fce4d56925942965fc05213)
+++ .idea/workspace.xml	(date 1604127808332)
@@ -2,7 +2,77 @@
 <project version="4">
   <component name="ChangeListManager">
     <list default="true" id="8f17b446-9a9d-4c34-af35-b3bc752ad62e" name="Default" comment="">
+      <change afterPath="$PROJECT_DIR$/out/src/IDEA快捷键.md" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/Python/pycharm快捷键.md" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/Python/常见Python语法问题.md" afterDir="false" />
       <change afterPath="$PROJECT_DIR$/out/src/Python/机器学习/numpy入门/numpy入门.md" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/java基础/1面向对象.md" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/java基础/img/java四种整形.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/java基础/img/jdk6下subString.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/java基础/img/jdk7subString解决.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/java基础/img/两种浮点数.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/java基础/img/四位数的补码表示.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/java基础/img/字符串不变性2.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/java基础/img/字符串不可变1.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/java基础/img/字符串不可变3.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/java基础/img/字符串不可变4.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/java基础/java字符串.md" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/java基础/test.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/markdown模板格式.md" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/swordOffer/数组/JZ4重建二叉树.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/中间件/redis/redis数据结构sds源码解析.md" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/工具/好用插件.md" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/1推荐书籍.md" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/2-1并发底层实现之volatile.md" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/2-2-1并发底层实现之synchronized.md" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/2-2-2synchronized补充自旋锁消除锁粗化.md" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/2-3并发编程原子操作实现原理.md" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/3-1 java内存模型.md" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/ReentrantLockDemo.java" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第三章/QQ截图20201027205150.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第三章/cache写回法导致内存可见性问题.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第三章/concurrent包实现最底层.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第三章/final写重排序.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第三章/final读规则.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第三章/happenbefore.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第三章/happenbefore两种禁止重排序.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第三章/jmm内存模型.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第三章/syn加锁内存语义.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第三章/syn锁释放内存语义.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第三章/volatiled读内存语义.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第三章/volatile写内存语义.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第三章/volatile写内存语义实现1.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第三章/volatile写插入内存屏障.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第三章/volatile写插入内存屏障1.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第三章/volatile读插入内存屏障.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第三章/volatile重排序规则.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第三章/三种指令重排序.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第三章/同步下顺序一致性和JMM内存模型.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第三章/同步顺序一致性模型.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第三章/四种内存屏障.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第三章/多线程并发修改共享数据.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第三章/多线程指令重排.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第三章/多线程指令重排2.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第三章/数据依赖.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第三章/非同步顺序一致性模型.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第三章/顺序一致性模型.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第二章/cas.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第二章/cpu与存储器总线数据交互.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第二章/markword64.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第二章/三种锁优缺点.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第二章/偏向锁对象头分析.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第二章/偏向锁撤销流程.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第二章/偏向锁状态的对象头.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第二章/偏向锁的获取和释放.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第二章/偏向锁的获取和释放2.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第二章/对象内存布局1.webp" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第二章/对象内存布局2.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第二章/对象头组成.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第二章/无锁状态对象头.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第二章/轻量级锁加锁过程.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第二章/轻量级锁标志.jpg" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第二章/轻量级锁膨胀过程.png" afterDir="false" />
+      <change afterPath="$PROJECT_DIR$/out/src/高并发/imgs/第二章/锁粗话monitor.png" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -157,6 +227,7 @@
       <workItem from="1604045524682" duration="94000" />
       <workItem from="1604051212488" duration="13996000" />
       <workItem from="1604108953584" duration="8426000" />
+      <workItem from="1604127459427" duration="341000" />
     </task>
     <task id="LOCAL-00001" summary="first time git commit">
       <created>1595583006825</created>
@@ -221,7 +292,14 @@
       <option name="project" value="LOCAL" />
       <updated>1603721054582</updated>
     </task>
-    <option name="localTasksCounter" value="10" />
+    <task id="LOCAL-00010" summary="并发第三章jmm">
+      <created>1604127667360</created>
+      <option name="number" value="00010" />
+      <option name="presentableId" value="LOCAL-00010" />
+      <option name="project" value="LOCAL" />
+      <updated>1604127667360</updated>
+    </task>
+    <option name="localTasksCounter" value="11" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
@@ -237,7 +315,8 @@
     <MESSAGE value="最新提交" />
     <MESSAGE value="增加博客网址" />
     <MESSAGE value="新增了syn的锁消除，粗化，嵌套所，自旋锁" />
-    <option name="LAST_COMMIT_MESSAGE" value="新增了syn的锁消除，粗化，嵌套所，自旋锁" />
+    <MESSAGE value="并发第三章jmm" />
+    <option name="LAST_COMMIT_MESSAGE" value="并发第三章jmm" />
   </component>
   <component name="WindowStateProjectService">
     <state x="261" y="0" key="#Plugins" timestamp="1604045348714">
Index: out/src/工具/好用插件.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- out/src/工具/好用插件.md	(date 1603545624000)
+++ out/src/工具/好用插件.md	(date 1603545624000)
@@ -0,0 +1,1 @@
+字节码插件 jclasslib
\ No newline at end of file
Index: out/src/IDEA快捷键.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- out/src/IDEA快捷键.md	(date 1601566407112)
+++ out/src/IDEA快捷键.md	(date 1601566407112)
@@ -0,0 +1,5 @@
+快速查找某个类ctr+alt+shift+n 查看该类的所有方法ctr+7
+
+查看某个方法被调用情况，navigage下面的call
+
+快速返回alt+ctrl+v
\ No newline at end of file
Index: out/src/高并发/1推荐书籍.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- out/src/高并发/1推荐书籍.md	(date 1603545624000)
+++ out/src/高并发/1推荐书籍.md	(date 1603545624000)
@@ -0,0 +1,2 @@
+《java并发编程的艺术》
+《并发编程实战》
\ No newline at end of file
Index: out/src/Python/机器学习/numpy入门/numpy入门.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- out/src/Python/机器学习/numpy入门/numpy入门.md	(date 1604045370256)
+++ out/src/Python/机器学习/numpy入门/numpy入门.md	(date 1604045370256)
@@ -0,0 +1,2 @@
+https://www.runoob.com/numpy/numpy-ndarray-object.html
+
Index: out/src/Python/常见Python语法问题.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- out/src/Python/常见Python语法问题.md	(date 1603545624000)
+++ out/src/Python/常见Python语法问题.md	(date 1603545624000)
@@ -0,0 +1,6 @@
+# 零碎知识
+## 如何理解python中 if __name__ == '__main__'
+
+第一次执行的脚本的模块的名字就是main,不管第一次执行脚本的文件名字，其余导入的py文件的模块名就是文件名
+
+https://www.zhihu.com/question/49136398
\ No newline at end of file
Index: out/src/高并发/2-2-1并发底层实现之synchronized.md
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- out/src/高并发/2-2-1并发底层实现之synchronized.md	(date 1603545624000)
+++ out/src/高并发/2-2-1并发底层实现之synchronized.md	(date 1603545624000)
@@ -0,0 +1,170 @@
+# synchronized概述
+> 多线程并发编程中synchronized一直是元老级角色，很多人都会称呼它为重量级锁。jdk1.6之前，如果用synchronzied进行同步的话，会直接进入到重量级锁，一次加锁就会进行用户态，内核态，用户态的切换。jdk1.6及以后版本（加锁不一定进入到内核态），引入了偏向所和轻量级锁，因此减少了锁的获得和释放性能开销。
+
+## synchronized的三种用法
+·对于普通同步方法，锁是当前实例对象。
+```java
+public synchronized void show (){
+}
+```
+·对于静态同步方法，锁是当前类的Class对象。
+
+```java
+public  class SynClass {
+	 public static synchronized void show (){}
+}
+```
+·对于同步方法块，锁是Synchonized括号里配置的对象。
+```java
+Object lock = new Object();
+
+public void show(){
+		monitorenter指令
+		synchronized(lock){
+		}
+		monitorexit指令
+	}
+```
+任何对象都与一个monitor关联，代码块同步是使用monitorenter和monitorexit字节码指令实现的。
+
+
+
+# 从打印对象头开始
+对象内存布局
+![对象内存布局](./imgs/第二章/对象内存布局1.webp)
+![对象内存布局](./imgs/第二章/对象内存布局2.png)
+一开始学习java时候，我们就知道java是面向对象的语言，而且万物都可以看作对象。我们常用的new Object()就可以创造一个对象，那么到底这个对象在内存中怎么表示的，如果你了解计算机组成原理的话应该知道，内存中存放的都是二进制数据，也就是说如果这个对象被new出来，那么在内存中一定是以二进制的形式进行存放的。
+```java
+public static void main(String[] args) {
+        System.out.println(ClassLayout.parseInstance(new Object()).toPrintable());
+    }
+	java.lang.Object object internals:
+ OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
+      0     4        (object header)                           01 00 00 00 (00000001 00000000 00000000 00000000) (1)
+      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
+      8     4        (object header)                           28 0f f7 16 (00101000 00001111 11110111 00010110) (385290024)
+     12     4        (loss due to the next object alignment)
+Instance size: 16 bytes
+Space losses: 0 bytes internal + 4 bytes external = 4 bytes total
+<dependency>
+            <groupId>org.openjdk.jol</groupId>
+            <artifactId>jol-core</artifactId>
+            <version>0.9</version>
+</dependency>
+```
+## 对象头的组成
+![对象头组成部分](./imgs/第二章/对象头组成.jpg)
+```cpp
+class oopDesc {
+  friend class VMStructs;
+  friend class JVMCIVMStructs;
+ private:
+  volatile markWord _mark;
+  union _metadata {
+    Klass*      _klass;
+    narrowKlass _compressed_klass;
+  } _metadata;
+```
+64位虚拟机下，markword分布结构（占用8个字节）
+![对象头组成部分](./imgs/第二章/markword64.jpg)
+
+# 锁的升级过程
+## 无锁状态
+```java
+public class PrintObjectHead {
+    public static void main(String[] args) {
+        Object obj=new Object();
+        System.out.println("计算hashcode之前的对象头");
+        System.out.println(ClassLayout.parseInstance(obj).toPrintable());
+        System.out.println(Integer.toHexString(obj.hashCode()));
+        System.out.println("计算hashcode之后的对象头"); // hashcode=f2a0b8e
+        System.out.println(ClassLayout.parseInstance(obj).toPrintable());
+    }
+}
+
+```
+![无锁对象头](./imgs/第二章/无锁状态对象头.png)
+## 偏向锁
+所谓的偏向，就是偏心，即锁会偏向于当前已经占有锁的线程。
+![偏向锁](./imgs/第二章/偏向锁状态的对象头.png)
+### 为什么引入偏向锁？
+一个加synchronized锁的代码在多数情况下并不存在竞争，而且同时多次由同一个线程获得。比如一个购物网站，深夜凌晨的访问量可能就是个位数，为了提高单个线程获得锁和释放锁的效率因此引入了偏向锁（单个线程获取锁不会在用户态，内核态，用户态之间切换）。
+### 偏向锁如何加锁
+```java
+Object obj=new Object();
+        //开启虚拟机偏向锁 -XX:BiasedLockingStartupDelay=0
+        System.out.println("无锁状态\n"+ClassLayout.parseInstance(obj).toPrintable()+"\n 线程ID"+
+        Long.toHexString(Thread.currentThread().getId()));
+        synchronized (obj){
+            System.out.println("无锁状态\n"+ClassLayout.parseInstance(obj).toPrintable()+"\n 线程ID"+
+                    Long.toHexString(Thread.currentThread().getId())+ "  hashcode"+Integer.toHexString(obj.hashCode()));
+            Thread.sleep(100000);
+        }
+无锁状态对象头
+ OFFSET  SIZE   TYPE DESCRIPTION                               VALUE
+      0     4        (object header)                           05 00 00 00 (00000101 00000000 00000000 00000000) (5)
+      4     4        (object header)                           00 00 00 00 (00000000 00000000 00000000 00000000) (0)
+      8     4        (object header)                           e5 21 e3 27 (11100101 00100001 11100011 00100111) (669196773)
+```
+这里无锁状态下，锁标志却是101（偏向锁的标志），因为我们开启了-XX:BiasedLockingStartupDelay=0，偏向锁0延迟，任何对象创建出来
+就是偏向锁状态，不再是无锁状态（001）。如果开启偏向锁延迟的话，新创建的对象的锁状态标志是001。0偏向锁延迟的条件下，即使对象不加synchronized锁，那么
+也是出于偏向锁状态。
+![偏向锁](./imgs/第二章/偏向锁对象头分析.png)
+一个线程访问同步块并获取锁时，会在对象头和栈帧中的锁记录里存储锁偏向的线程ID，以后该线程在进入和退出
+同步块时不需要进行CAS操作来加锁和解锁，只需简单地测试一下对象头的Mark Word里是否
+存储着指向当前线程的偏向锁。因此，这个偏向锁是可重入锁，同一个线程可以多次synchronized(同一个object)
+
+-XX:BiasedLockingStartupDelay=0:零延迟条件下的偏向锁，a线程加锁过程如下。新对象obj锁特征就是101，如果a发现对象头内线程id是指向当前线程a线程。
+则可以直接重入该锁。如果a线程发现对象头线程id不是指向自己，则通过cas(无锁状态下ThreadId占用的位置二进制数据,myThreadId)进行竞争尝试该偏向锁指向自己a。
+
+-XX:BiasedLockingStartupDelay ！=0。偏向锁由延迟的条件下，对象初始化时候锁标志是01，偏向锁标志0，此时线程会通过cas方式加锁设置偏向锁标志=1，
+并且偏向锁线程id是自己线程id。
+
+因此偏向锁非常适合同一个线程多次加锁，或者多个线程交替加锁。因此偏向锁的加锁检查等等操作只是进行cas等操作，不需要切换到内核态，因此相比于重量锁耗时非常短。
+
+### 偏向锁释放
+偏向锁使用了一种等到竞争出现才释放锁的机制，所以当其他线程尝试竞争偏向锁时，
+持有偏向锁的线程才会释放锁。
+![偏向锁](./imgs/第二章/偏向锁撤销流程.png)
+### 偏向锁关闭
+
+如果你确定应用程序里所有的锁通常情况下处于竞争状态，可以通过JVM参数关闭偏向锁：-XX:-
+UseBiasedLocking=false，那么程序默认会进入轻量级锁状态
+
+![偏向锁](./imgs/第二章/偏向锁的获取和释放2.png)
+## 轻量级锁
+![偏向锁](./imgs/第二章/轻量级锁标志.jpg)
+
+### 加锁过程
+
+#### 公共操作
+1. 当前线程栈桢中创建存储锁记录(lock record)的空间
+2. 原来的对象头markword复制到锁记录（lock record）中
+3. 栈桢中的ower指针指向markword
+
+#### 大家抢锁
+尝试使用cas修改markword中（指向锁记录指针），修改成功表示成功抢到轻量级锁
+修改失败：有人在占用轻量级锁，接着会自旋cas修改markword中（指向锁记录指针），可以自适应自旋次数。自旋不是阻塞，仍然消耗cpu资源，相比于重量锁的信号量性能消耗很低。
+因此，如果竞争非常激烈的话，会有很多线程都在不停的自旋消耗cpu，因此此时应该升级为重量级锁。
+
+![偏向锁](./imgs/第二章/轻量级锁加锁过程.png)
+### 解锁过程
+
+解锁成功-》偏向锁到无锁状态：会使用原子的CAS操作储锁记录(lock record)中的Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生，锁标志变为001，无锁状态
+
+解锁失败-》偏向锁到重量级锁：解锁失败说明有其余线程已经修改了markword中的锁记录指针，此时锁已经被其余线程膨胀到重量级锁，并且此时对象头中的锁纪律指针是指向monitor,其余线程都阻塞在monitor队列中。
+此时轻量级锁线程释放锁，并且唤醒阻塞在monitor上的线程。
+
+### 轻量锁膨胀过程
+![偏向锁](./imgs/第二章/轻量级锁膨胀过程.png)
+
+## 重量级锁
+重量级锁是依赖对象内部的monitor锁来实现的，而monitor又依赖操作系统的MutexLock(互斥锁)来实现的，所以重量级锁也被成为互斥锁。
+## 锁状态对比
+![偏向锁](./imgs/第二章/三种锁优缺点.png)
+
+## hollis大神关于synchronized相关总结
+
+未深入看
+
+http://47.103.216.138/archives/tag/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E5%A4%9A%E7%BA%BF%E7%A8%8B
\ No newline at end of file
diff --git out/src/高并发/2-1并发底层实现之volatile.md out/src/高并发/2-1并发底层实现之volatile.md
new file mode 100644
