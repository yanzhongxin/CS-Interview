


#自旋锁
引入自旋锁背景：jdk1.6之前的synchronzied都是重量级锁，通过对象的Monitor进行加锁解锁，这是一把重量级锁
锁的申请需要操作系统的互斥信号量支持，因此会导致从用户态，内核态，用户态的切换，操作系统对线程状态的切换
开销很大。因此jdk开发团队引入了自旋锁提高获取锁释放锁性能。

例子：重量级锁情况-》去银行柜台办理业务，a用户取完号码后被叫到柜台，此时b用户也来办理业务取号，jdk1.6之前的做法是，让用户自己
走到休息区（操作系统帮助阻塞），自己做自己的事情，等待被叫号到柜台（操作系统帮助唤醒）。如果每个人去柜台只是去取款，耗时非常短，
但是重量级锁仍然要求操作系统帮助阻塞和唤醒（线程状态切换），很明显线程阻塞唤醒性能消耗远大于取款消耗，很明显不合理。

引入自旋锁之后-》 银行引入了取款机，用户只需要排队去取款机上取款就可以，不需要进入到休息区（线程阻塞），当a用户在取款时候，后面的b用户只需要不断地
观察（自旋）a是否取款完成，如果发现a取款完成，后面直接上去取款。b用户线程始终出于用户态，随然自旋观察a用户，但是这个耗时相比于线程状态切换，耗时非常短。
但是如果a后面有很多的排队用户，每个用户都在不停的自旋观察a是否取款结束，那么cpu自旋所占用的时间就变得很大。

## 自旋和阻塞区别
最大区别就是是否有线程状态的切换。自旋状态下，线程仍然是用户态，不断消耗cpu运行时间。但是阻塞状态下（休息区），线程从用户态到内核态
转换，并且出于阻塞态的阻塞队列中，此时不会消耗cpu运行时间。

#锁消除
#锁优化